# TicketsManager单元测试指南

## 概述

本项目为TicketsManager模块创建了完全隔离的单元测试环境,可以在不依赖QuantConnect平台的情况下验证订单生命周期管理逻辑。

**关键特性**:
- ✅ **完全隔离**: 测试代码与生产代码物理分离,互不影响
- ✅ **Mock模拟**: 使用Mock对象模拟QuantConnect组件
- ✅ **极端场景**: 可以测试真实回测无法触发的异常情况
- ✅ **快速执行**: 秒级运行,无需等待完整回测

## 文件结构

```
BayesCointegration/
├── src/
│   └── TicketsManager.py              ← 生产代码(不变)
├── tests/
│   ├── __init__.py                    ← 测试包标记
│   ├── mocks/
│   │   ├── __init__.py
│   │   ├── mock_qc_objects.py         ← Mock QuantConnect类
│   │   └── algorithm_imports_stub.py  ← AlgorithmImports桩模块
│   ├── test_tickets_manager.py        ← 完整测试套件(7个用例)
│   └── test_simple.py                 ← 简化测试(3个核心用例)
└── .gitignore                          ← 排除测试缓存
```

## 运行测试

### 方法1: 简化测试(推荐)

```bash
# 在项目根目录运行
python tests/test_simple.py

# 输出示例:
# ==================================================
# TicketsManager 核心功能测试
# ==================================================
# [PASS] 正常完成+回调验证通过
# [PASS] 单腿Canceled检测正确
# [PASS] Pending状态+锁定机制正确
# ==================================================
# 结果: 3/3 通过
# ==================================================
```

### 方法2: 完整测试套件

```bash
# 包含7个详细测试用例
python tests/test_tickets_manager.py

# 注意: Windows环境可能有Unicode编码问题,建议使用test_simple.py
```

### 方法3: 使用pytest(可选)

```bash
# 安装pytest
pip install pytest

# 运行测试
pytest tests/ -v
```

## 测试覆盖场景

### 核心测试(test_simple.py)

| 测试用例 | 场景 | 验证点 |
|---------|------|--------|
| **test_normal_completion** | 双腿都Filled | status="COMPLETED", 回调触发, 数量记录正确 |
| **test_one_leg_canceled** | 一腿Filled,一腿Canceled | status="ANOMALY", 进入异常集合, 回调不触发 |
| **test_pending_state** | 一腿Filled,一腿Submitted | status="PENDING", 配对锁定 |

### 完整测试(test_tickets_manager.py)

额外包含:
- **test_both_legs_canceled**: 双腿都Canceled → ANOMALY
- **test_one_leg_invalid**: 一腿Invalid → ANOMALY
- **test_multiple_anomaly_pairs**: 多配对场景,精确检测异常
- **test_no_callback_on_anomaly**: 验证异常时数据不污染

## 设计原理

### 为什么测试不影响生产代码?

#### 1. 物理隔离

```
├── src/TicketsManager.py      ← 生产代码
└── tests/
    ├── mocks/                  ← Mock对象
    └── test_*.py               ← 测试代码
```

- QuantConnect回测时只加载`src/`和`main.py`
- `tests/`目录完全被忽略
- 测试代码**导入**生产代码,但生产代码不知道测试存在

#### 2. Mock对象替换

测试环境:
```python
# 使用Mock版本的QCAlgorithm
mock_algo = MockAlgorithm()
tm = TicketsManager(mock_algo, ...)

# TicketsManager调用algo.Debug()时,实际调用MockAlgorithm.Debug()
```

回测环境:
```python
# 使用真实的QCAlgorithm
self.tickets_manager = TicketsManager(self, ...)

# TicketsManager调用self.Debug()时,实际调用QCAlgorithm.Debug()
```

两者**完全独立**!

#### 3. 模块注入技术

```python
# tests/test_*.py
import tests.mocks.algorithm_imports_stub as AlgorithmImports
sys.modules['AlgorithmImports'] = AlgorithmImports  # ← 魔法在这里

# 之后import src.TicketsManager时,它会使用Mock的AlgorithmImports
from src.TicketsManager import TicketsManager
```

这样TicketsManager可以正常import OrderStatus, OrderTicket等类型,但实际上都是Mock版本。

## 验证测试隔离性

### 检查生产代码未被修改

```bash
git status src/

# 应该输出:
# nothing to commit (working directory clean)
# 或只有 __pycache__/ (Python自动生成的缓存)
```

### 运行回测验证不受影响

```bash
# 运行完整回测
lean backtest BayesCointegration

# 回测结果应该与测试前完全相同
```

### 删除测试目录验证

```bash
# 临时删除tests目录
mv tests tests_backup

# 运行回测,应该完全正常
lean backtest BayesCointegration

# 恢复测试目录
mv tests_backup tests
```

## 扩展测试

### 添加新测试用例

编辑`tests/test_simple.py`:

```python
def test_my_scenario():
    """测试: 我的新场景"""
    print("\n[TEST] 我的新场景")

    # 创建Mock对象
    mock_algo = MockAlgorithm()
    mock_pairs_manager = MockPairsManager()
    tm = TicketsManager(mock_algo, mock_pairs_manager)

    # 模拟场景
    ticket1 = MockOrderTicket(999, MockSymbol("XXX"), MockOrderStatus.Filled)
    ticket2 = MockOrderTicket(1000, MockSymbol("YYY"), MockOrderStatus.PartiallyFilled)

    tm.register_tickets("(XXX, YYY)", [ticket1, ticket2], "OPEN")

    # 验证预期
    status = tm.get_pair_status("(XXX, YYY)")
    assert status == "PENDING"  # PartiallyFilled也是未完成

    print("[PASS] 我的新场景测试通过\n")

# 在if __name__ == "__main__"中添加:
tests = [
    test_normal_completion,
    test_one_leg_canceled,
    test_pending_state,
    test_my_scenario  # ← 新测试
]
```

### 扩展Mock对象

如果需要模拟更多QuantConnect类,编辑`tests/mocks/mock_qc_objects.py`:

```python
class MockSecurityPortfolioManager:
    """扩展Portfolio功能"""
    def __init__(self):
        self._holdings = {}
        self.TotalPortfolioValue = 100000  # 添加新属性

    # ... 其他方法
```

## 常见问题

### Q1: 测试会不会影响我的回测结果?

**A**: 完全不会! 测试代码与回测环境完全隔离,QuantConnect引擎不会加载`tests/`目录。

### Q2: 为什么test_tickets_manager.py在Windows上报Unicode错误?

**A**: Windows cmd默认使用GBK编码,无法显示特殊Unicode符号(✓✅❌等)。
解决方案:
- 使用`test_simple.py`(无特殊符号)
- 或在PowerShell中运行(支持UTF-8)

### Q3: 如何在CI/CD中运行测试?

**A**: 添加到GitHub Actions:

```yaml
# .github/workflows/test.yml
name: Unit Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-python@v2
        with:
          python-version: 3.11
      - run: python tests/test_simple.py
```

### Q4: Mock对象会不会与真实QuantConnect行为不一致?

**A**: 可能会! Mock对象只实现了TicketsManager需要的最小接口。
建议:
- 单元测试验证**核心逻辑**
- 纸上交易验证**真实环境**
- 两者结合才能全面保证质量

### Q5: 如何测试OnOrderEvent的真实回调?

**A**: 单元测试中手动调用`tm.on_order_event(MockOrderEvent(...))`模拟。
真实回调链(Framework自动触发)只能在QuantConnect环境验证。

## 后续优化建议

### 短期(已完成)
- ✅ 创建Mock对象基础设施
- ✅ 覆盖3个核心异常场景
- ✅ 验证测试隔离性

### 中期(可选)
- 使用pytest框架(更强大的断言和报告)
- 添加代码覆盖率检查(`coverage.py`)
- 扩展Mock对象支持更多QuantConnect类

### 长期(生产准备)
- 集成到CI/CD管道
- 在纸上交易中验证真实异常
- 建立异常处理文档化标准

## 相关文档

- **订单回调机制详解**: `docs/订单回调机制详解.md` - 理解事件驱动架构
- **CHANGELOG**: `docs/CHANGELOG.md` - v6.5.0版本记录

## 总结

通过创建完全隔离的单元测试环境,我们实现了:
1. **快速验证**: 几秒钟验证需要数周才能在真实环境中出现的异常
2. **安全实验**: 可以随意测试极端场景,不影响生产代码
3. **重构安全网**: 未来修改代码时,测试确保不破坏现有功能
4. **文档价值**: 测试代码就是最好的使用示例

**下一步**: 部署到纸上交易,在真实市场环境中验证异常处理完整性。
