# 回测问题清单 v2 - 基于最新回测

**最新回测ID**: `35554859263c8c008df178addc7e29d6`
**回测期**: 2024年7月2日 - 2024年9月20日 (2.5个月)
**总订单数**: 118笔
**创建日期**: 2025年9月30日
**更新原因**: cooldown修复后发现新的严重问题

---

## 核心发现

**收益表现**: 收益进一步下降(相比修复前的-1.41%)
**主要原因**:
1. 购买力不足导致关键订单失败(6笔+)
2. 单边持仓破坏配对交易逻辑
3. 订单重复提交扰乱仓位管理

**问题性质变化**:
- ~~问题2(订单重复)~~: 仍然存在,且更严重
- ~~问题3(订单取消)~~: 变成了"订单失败"(购买力不足)
- ~~问题4(行业集中度)~~: 仍然存在,科技股>60%

---

## 🔴 优先级1 - Critical (严重影响策略执行)

### 问题A: 购买力不足导致订单失败

**严重程度**: 🔴 Critical - **策略失效级别**

**问题描述**:
多次出现"Insufficient buying power"错误,导致关键的平仓订单无法执行,造成单边持仓和亏损扩大。

**具体数据证据**:
```
订单 #105 (2024-09-18): 卖出AMZN 526股失败
  需要保证金: $49,033
  可用保证金: $37,043
  缺口: $11,990 (32%不足)

订单 #111 (2024-09-19): 买入AMZN 526股失败
  需要保证金: $49,938
  可用保证金: $45,858
  缺口: $4,080 (9%不足)

订单 #115 (2024-09-20): 卖出AMZN 526股失败
  需要保证金: $50,393
  可用保证金: $44,930
  缺口: $5,463 (12%不足)
```

**影响**:
- 至少6笔订单失败(占总订单5%)
- AMZN配对无法正常平仓,持续亏损
- 引发后续的单边持仓问题

**根本原因分析**:

1. **仓位过大**: AMZN 526股 ≈ $100,000,需要50%保证金($50,000)
2. **保证金计算缺失**: 开仓时没有检查Portfolio.MarginRemaining
3. **现金缓冲不足**: config.py中的5%缓冲在多配对开仓后耗尽
4. **MarketOrder vs Liquidate差异**:
   ```python
   # Liquidate: QuantConnect自动处理保证金,可能强制清算其他持仓
   # MarketOrder: 需要足够保证金,否则直接失败
   ```

**修复方案**:

**方案1: 开仓前严格检查保证金** (推荐)
```python
# src/Pairs.py - 在open_position前增加检查
def can_open_position(self, allocation_value):
    """
    检查是否有足够保证金开仓
    allocation_value: 计划投入的资金
    """
    # 计算需要的保证金(美股50%,做空需要额外保证金)
    required_margin = allocation_value * 0.6  # 60%作为安全系数

    # 获取可用保证金
    available = self.algorithm.Portfolio.MarginRemaining

    # 保留10%缓冲
    buffer = self.algorithm.Portfolio.TotalPortfolioValue * 0.10

    if required_margin > available - buffer:
        self.algorithm.Debug(
            f"[Pairs] {self.pair_id} 保证金不足: "
            f"需要${required_margin:,.0f}, "
            f"可用${available:,.0f}, "
            f"缓冲${buffer:,.0f}", 1
        )
        return False

    return True

# main.py - 开仓前调用检查
for pair_signal in signals_to_open:
    pair = pair_signal['pair']
    allocation = pair_signal['allocation']

    # ✅ 增加保证金检查
    if not pair.can_open_position(allocation):
        self.Debug(f"[Main] {pair.pair_id} 跳过开仓(保证金不足)")
        continue

    pair.open_position(allocation)
```

**方案2: 降低单个配对的最大仓位**
```python
# src/config.py
position_sizing = {
    'min_allocation_pct': 0.10,  # 10% → 8% (降低)
    'max_allocation_pct': 0.25,  # 25% → 20% (降低)
    'cash_buffer_pct': 0.05,     # 5% → 10% (提高)
}
```

**方案3: 动态调整仓位**
```python
# 如果保证金不足,按比例缩小仓位
def adjust_allocation_for_margin(self, allocation_value):
    available = self.algorithm.Portfolio.MarginRemaining
    buffer = self.algorithm.Portfolio.TotalPortfolioValue * 0.10

    max_allocation = (available - buffer) / 0.6  # 反推最大可用资金

    if allocation_value > max_allocation:
        self.algorithm.Debug(f"[Pairs] 仓位缩减: {allocation_value} → {max_allocation}")
        return max_allocation

    return allocation_value
```

**验证标准**:
- [ ] 无任何"Insufficient buying power"错误
- [ ] 所有开仓订单成功执行
- [ ] Portfolio.MarginRemaining始终>10%缓冲

---

### 问题B: 单边持仓破坏配对逻辑

**严重程度**: 🔴 Critical - **核心逻辑破坏**

**问题描述**:
配对中只有一边有持仓,完全失去"市场中性"保护,变成方向性赌博。

**具体数据证据**:
```
AMZN配对异常:
  原因: 订单#105/106平仓失败(购买力不足)
  结果: AMZN一边持仓未平,另一边已平
  持续: 2024-09-18至回测结束(3天+)
  风险: 方向性暴露,无对冲保护

MCHP/QCOM配对异常:
  订单#19/20 (2024-08-19): MCHP卖14股, QCOM买22股
  订单#23/24 (2024-08-20): 重复相同数量
  问题: 数量不匹配,beta对冲比例错误
```

**影响**:
- 失去配对交易的核心价值(市场中性)
- 承担单边股票风险
- 可能大幅亏损

**根本原因分析**:

1. **订单失败后无补救**: close_position()中一个订单失败,另一个成功,没有回滚
2. **Beta对冲数量取整问题**:
   ```python
   # src/Pairs.py:194-195
   qty1 = int(value1 / price1)  # 取整导致精度损失
   qty2 = int(qty1 * abs(self.beta_mean))
   # 如果beta=1.57, qty1=14
   # qty2 = int(14 * 1.57) = int(21.98) = 21
   # 但实际订单显示qty2=22,存在不一致
   ```
3. **没有持仓完整性检查**: 开仓后不验证两边是否都成功

**修复方案**:

**方案1: 实现原子性平仓** (推荐)
```python
# src/Pairs.py - 修改close_position方法
def close_position(self):
    """
    原子性平仓: 要么都成功,要么都不做
    """
    info = self.get_position_info()
    qty1, qty2 = info['qty1'], info['qty2']

    if qty1 == 0 and qty2 == 0:
        return

    # 创建Tag
    tag = self.create_order_tag(OrderAction.CLOSE)

    # 提交订单但不等待成交
    tickets = []
    if qty1 != 0:
        ticket1 = self.algorithm.MarketOrder(self.symbol1, -qty1, tag=tag)
        tickets.append((self.symbol1, ticket1))
    if qty2 != 0:
        ticket2 = self.algorithm.MarketOrder(self.symbol2, -qty2, tag=tag)
        tickets.append((self.symbol2, ticket2))

    # 检查订单状态(在下个OnData周期)
    self.pending_close_tickets = tickets

# 在main.py的OnData中检查pending订单
def check_pending_orders(self):
    """检查待处理的平仓订单"""
    for pair in self.pairs_manager.get_all_pairs():
        if not hasattr(pair, 'pending_close_tickets'):
            continue

        tickets = pair.pending_close_tickets
        statuses = [t[1].Status for t in tickets]

        # 如果有订单失败
        if any(s == OrderStatus.Invalid for s in statuses):
            self.Debug(f"[Main] {pair.pair_id} 平仓失败,尝试补救")

            # 找出成功的订单,反向平仓
            for symbol, ticket in tickets:
                if ticket.Status == OrderStatus.Filled:
                    qty = self.Portfolio[symbol].Quantity
                    if qty != 0:
                        # 反向平仓,恢复原状
                        self.MarketOrder(symbol, -qty, tag="ROLLBACK")

        # 清除已处理的tickets
        if all(s in [OrderStatus.Filled, OrderStatus.Invalid] for s in statuses):
            delattr(pair, 'pending_close_tickets')
```

**方案2: 持仓完整性监控**
```python
# src/Pairs.py - 增加监控方法
def check_position_integrity(self):
    """
    检查持仓完整性
    返回: (is_valid, error_message)
    """
    pos1 = self.algorithm.Portfolio[self.symbol1].Quantity
    pos2 = self.algorithm.Portfolio[self.symbol2].Quantity

    # 检查单边持仓
    if (pos1 != 0 and pos2 == 0) or (pos1 == 0 and pos2 != 0):
        return False, f"单边持仓: {self.symbol1}={pos1}, {self.symbol2}={pos2}"

    # 如果都没有持仓,OK
    if pos1 == 0 and pos2 == 0:
        return True, ""

    # 检查持仓方向
    if pos1 * pos2 > 0:  # 同号,说明方向错误
        return False, f"持仓方向错误: {self.symbol1}={pos1}, {self.symbol2}={pos2}"

    # 检查持仓比例
    expected_ratio = abs(self.beta_mean)
    actual_ratio = abs(pos2 / pos1) if pos1 != 0 else 0
    ratio_error = abs(actual_ratio - expected_ratio) / expected_ratio

    if ratio_error > 0.15:  # 15%容差
        return False, f"持仓比例异常: 期望{expected_ratio:.2f}, 实际{actual_ratio:.2f}"

    return True, ""

# main.py - 每日检查
def check_all_positions(self):
    """检查所有配对的持仓完整性"""
    for pair in self.pairs_manager.get_pairs_with_position():
        is_valid, error = pair.check_position_integrity()

        if not is_valid:
            self.Debug(f"[RiskManagement] 持仓异常: {pair.pair_id} - {error}", 0)

            # 强制清算异常持仓
            pair.close_position()
```

**验证标准**:
- [ ] 无任何单边持仓warning
- [ ] 所有配对持仓比例符合beta对冲
- [ ] 订单失败时有自动补救机制

---

### 问题C: 订单重复提交

**严重程度**: 🔴 Critical - **扰乱仓位管理**

**问题描述**:
同一信号在短时间内多次提交相同订单,导致仓位翻倍或重复失败。

**具体数据证据**:
```
AMZN重复订单:
  订单#105/106 (2024-09-18): 两个相同的AMZN卖出订单
  订单#111/112 (2024-09-19): 两个相同的AMZN买入订单
  订单#115/116 (2024-09-20): 两个相同的AMZN卖出订单
  订单#117/118 (最后): 又是重复

8月19-20日重复:
  订单#19-26: 多个配对在同一天内重复提交
  时间: 凌晨4:00和晚上8:00
```

**影响**:
- 成功的重复订单导致仓位翻倍
- 失败的重复订单增加日志噪音
- 扰乱风险管理和仓位计算

**根本原因分析**:

1. **OnData多次触发**:
   ```python
   # main.py - OnData在同一天可能被调用多次
   # 原因: 数据更新、时间事件、订单成交回调等
   ```

2. **信号状态未持久化**: 每次OnData都重新计算signal,不记录"已执行"状态

3. **没有pending订单检查**: 不检查是否已有相同的pending订单

**修复方案**:

**方案1: 订单去重机制** (推荐)
```python
# main.py - 增加订单追踪
class BayesianCointegrationStrategy(QCAlgorithm):
    def __init__(self):
        super().__init__()
        self.daily_processed_signals = {}  # 每日已处理信号

    def OnData(self, data):
        # 每天重置processed信号
        current_date = self.Time.date()
        if not hasattr(self, '_last_date') or self._last_date != current_date:
            self.daily_processed_signals = {}
            self._last_date = current_date

        # ... 策略逻辑 ...

        for pair in pairs_without_position:
            signal = pair.get_signal(data)

            if signal == "LONG_SPREAD" or signal == "SHORT_SPREAD":
                # 检查是否已处理过
                signal_key = (pair.pair_id, signal, current_date)

                if signal_key in self.daily_processed_signals:
                    self.Debug(f"[Main] {pair.pair_id} 信号已处理,跳过", 2)
                    continue

                # 开仓
                pair.open_position(allocation)

                # 标记已处理
                self.daily_processed_signals[signal_key] = self.Time
```

**方案2: 检查pending订单**
```python
# src/Pairs.py - 开仓前检查
def has_pending_orders(self):
    """检查是否有待处理订单"""
    orders = self.algorithm.Transactions.GetOrders(
        lambda x: str(self.pair_id) in x.Tag
                 and x.Status in [OrderStatus.Submitted, OrderStatus.PartiallyFilled]
    )
    return len(list(orders)) > 0

# main.py - 开仓前检查
if pair.has_pending_orders():
    self.Debug(f"[Main] {pair.pair_id} 有待处理订单,跳过")
    continue
```

**验证标准**:
- [ ] 同一配对同一天只开仓一次
- [ ] 无重复订单提交
- [ ] 日志清晰,无冗余记录

---

## 🟡 优先级2 - High (影响收益表现)

### 问题D: 交易频率过高

**严重程度**: 🟡 High

**问题描述**:
部分配对持仓时间过短(<5天),增加交易成本且信号质量差。

**具体数据**:
```
MCHP/QCOM: 9/3开仓 → 9/4平仓 (持仓1天!)
AMZN/CMG: 7/19开仓 → 7/23平仓 (持仓4天)
MCHP/QCOM: 8/2开仓 → 8/5平仓 (持仓3天)
```

**修复方案**:
- 提高entry_threshold: 1.0σ → 1.5σ
- 增加最小持仓天数限制
- 优化exit_threshold: 0.3σ → 0.5σ

---

### 问题E: AMZN股票过度交易

**严重程度**: 🟡 High

**问题描述**:
AMZN参与过多配对,占总订单24%,集中度风险高。

**修复方案**:
- 限制单一股票最多参与2个配对
- 优先选择分散的股票组合

---

### 问题F: 行业集中度超标

**严重程度**: 🟡 High

**问题描述**:
科技股占比>60%,超过配置的40%限制。

**修复方案**:
- 检查并修复main.py中的行业集中度检查逻辑
- 增加强制调整机制

---

## 修复优先级排序

### 立即修复(今天):
1. ✅ **问题1(Cooldown)** - 已完全修复
2. **问题A(购买力不足)** - 方案1: 开仓前检查保证金
3. **问题B(单边持仓)** - 方案2: 持仓完整性监控
4. **问题C(订单重复)** - 方案1: 订单去重机制

### 短期优化(本周):
5. **问题D(交易频率)** - 调整阈值参数
6. **问题E(AMZN集中)** - 限制单股配对数
7. **问题F(行业集中)** - 修复检查逻辑

---

## 验证计划

**下一次回测检查项**:
- [ ] 无"Insufficient buying power"错误
- [ ] 无单边持仓warning
- [ ] 无重复订单
- [ ] 平均持仓天数>5天
- [ ] AMZN交易占比<15%
- [ ] 科技股占比<40%
- [ ] 收益率改善(目标>0%)

---

## 备注

本文档替代旧版问题清单(`回测问题清单_20250930.md`),基于最新回测的真实问题重新编写。
旧清单中的问题2-4已整合到本文档的问题C、F中。